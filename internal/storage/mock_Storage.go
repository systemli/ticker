// Code generated by mockery v2.36.0. DO NOT EDIT.

package storage

import (
	mock "github.com/stretchr/testify/mock"
	pagination "github.com/systemli/ticker/internal/api/pagination"
	gorm "gorm.io/gorm"
)

// MockStorage is an autogenerated mock type for the Storage type
type MockStorage struct {
	mock.Mock
}

// AddTickerUser provides a mock function with given fields: ticker, user
func (_m *MockStorage) AddTickerUser(ticker *Ticker, user *User) error {
	ret := _m.Called(ticker, user)

	var r0 error
	if rf, ok := ret.Get(0).(func(*Ticker, *User) error); ok {
		r0 = rf(ticker, user)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteAttachmentsByMessage provides a mock function with given fields: message
func (_m *MockStorage) DeleteAttachmentsByMessage(message Message) error {
	ret := _m.Called(message)

	var r0 error
	if rf, ok := ret.Get(0).(func(Message) error); ok {
		r0 = rf(message)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteMessage provides a mock function with given fields: message
func (_m *MockStorage) DeleteMessage(message Message) error {
	ret := _m.Called(message)

	var r0 error
	if rf, ok := ret.Get(0).(func(Message) error); ok {
		r0 = rf(message)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteMessages provides a mock function with given fields: ticker
func (_m *MockStorage) DeleteMessages(ticker Ticker) error {
	ret := _m.Called(ticker)

	var r0 error
	if rf, ok := ret.Get(0).(func(Ticker) error); ok {
		r0 = rf(ticker)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteTicker provides a mock function with given fields: ticker
func (_m *MockStorage) DeleteTicker(ticker Ticker) error {
	ret := _m.Called(ticker)

	var r0 error
	if rf, ok := ret.Get(0).(func(Ticker) error); ok {
		r0 = rf(ticker)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteTickerUser provides a mock function with given fields: ticker, user
func (_m *MockStorage) DeleteTickerUser(ticker *Ticker, user *User) error {
	ret := _m.Called(ticker, user)

	var r0 error
	if rf, ok := ret.Get(0).(func(*Ticker, *User) error); ok {
		r0 = rf(ticker, user)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteTickerUsers provides a mock function with given fields: ticker
func (_m *MockStorage) DeleteTickerUsers(ticker *Ticker) error {
	ret := _m.Called(ticker)

	var r0 error
	if rf, ok := ret.Get(0).(func(*Ticker) error); ok {
		r0 = rf(ticker)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteUpload provides a mock function with given fields: upload
func (_m *MockStorage) DeleteUpload(upload Upload) error {
	ret := _m.Called(upload)

	var r0 error
	if rf, ok := ret.Get(0).(func(Upload) error); ok {
		r0 = rf(upload)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteUploads provides a mock function with given fields: uploads
func (_m *MockStorage) DeleteUploads(uploads []Upload) {
	_m.Called(uploads)
}

// DeleteUploadsByTicker provides a mock function with given fields: ticker
func (_m *MockStorage) DeleteUploadsByTicker(ticker Ticker) error {
	ret := _m.Called(ticker)

	var r0 error
	if rf, ok := ret.Get(0).(func(Ticker) error); ok {
		r0 = rf(ticker)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteUser provides a mock function with given fields: user
func (_m *MockStorage) DeleteUser(user User) error {
	ret := _m.Called(user)

	var r0 error
	if rf, ok := ret.Get(0).(func(User) error); ok {
		r0 = rf(user)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// FindMessage provides a mock function with given fields: tickerID, messageID, opts
func (_m *MockStorage) FindMessage(tickerID int, messageID int, opts ...func(*gorm.DB) *gorm.DB) (Message, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, tickerID, messageID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 Message
	var r1 error
	if rf, ok := ret.Get(0).(func(int, int, ...func(*gorm.DB) *gorm.DB) (Message, error)); ok {
		return rf(tickerID, messageID, opts...)
	}
	if rf, ok := ret.Get(0).(func(int, int, ...func(*gorm.DB) *gorm.DB) Message); ok {
		r0 = rf(tickerID, messageID, opts...)
	} else {
		r0 = ret.Get(0).(Message)
	}

	if rf, ok := ret.Get(1).(func(int, int, ...func(*gorm.DB) *gorm.DB) error); ok {
		r1 = rf(tickerID, messageID, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindMessagesByTicker provides a mock function with given fields: ticker, opts
func (_m *MockStorage) FindMessagesByTicker(ticker Ticker, opts ...func(*gorm.DB) *gorm.DB) ([]Message, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ticker)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 []Message
	var r1 error
	if rf, ok := ret.Get(0).(func(Ticker, ...func(*gorm.DB) *gorm.DB) ([]Message, error)); ok {
		return rf(ticker, opts...)
	}
	if rf, ok := ret.Get(0).(func(Ticker, ...func(*gorm.DB) *gorm.DB) []Message); ok {
		r0 = rf(ticker, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]Message)
		}
	}

	if rf, ok := ret.Get(1).(func(Ticker, ...func(*gorm.DB) *gorm.DB) error); ok {
		r1 = rf(ticker, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindMessagesByTickerAndPagination provides a mock function with given fields: ticker, _a1, opts
func (_m *MockStorage) FindMessagesByTickerAndPagination(ticker Ticker, _a1 pagination.Pagination, opts ...func(*gorm.DB) *gorm.DB) ([]Message, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ticker, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 []Message
	var r1 error
	if rf, ok := ret.Get(0).(func(Ticker, pagination.Pagination, ...func(*gorm.DB) *gorm.DB) ([]Message, error)); ok {
		return rf(ticker, _a1, opts...)
	}
	if rf, ok := ret.Get(0).(func(Ticker, pagination.Pagination, ...func(*gorm.DB) *gorm.DB) []Message); ok {
		r0 = rf(ticker, _a1, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]Message)
		}
	}

	if rf, ok := ret.Get(1).(func(Ticker, pagination.Pagination, ...func(*gorm.DB) *gorm.DB) error); ok {
		r1 = rf(ticker, _a1, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindTickerByDomain provides a mock function with given fields: domain, opts
func (_m *MockStorage) FindTickerByDomain(domain string, opts ...func(*gorm.DB) *gorm.DB) (Ticker, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, domain)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 Ticker
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...func(*gorm.DB) *gorm.DB) (Ticker, error)); ok {
		return rf(domain, opts...)
	}
	if rf, ok := ret.Get(0).(func(string, ...func(*gorm.DB) *gorm.DB) Ticker); ok {
		r0 = rf(domain, opts...)
	} else {
		r0 = ret.Get(0).(Ticker)
	}

	if rf, ok := ret.Get(1).(func(string, ...func(*gorm.DB) *gorm.DB) error); ok {
		r1 = rf(domain, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindTickerByID provides a mock function with given fields: id, opts
func (_m *MockStorage) FindTickerByID(id int, opts ...func(*gorm.DB) *gorm.DB) (Ticker, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, id)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 Ticker
	var r1 error
	if rf, ok := ret.Get(0).(func(int, ...func(*gorm.DB) *gorm.DB) (Ticker, error)); ok {
		return rf(id, opts...)
	}
	if rf, ok := ret.Get(0).(func(int, ...func(*gorm.DB) *gorm.DB) Ticker); ok {
		r0 = rf(id, opts...)
	} else {
		r0 = ret.Get(0).(Ticker)
	}

	if rf, ok := ret.Get(1).(func(int, ...func(*gorm.DB) *gorm.DB) error); ok {
		r1 = rf(id, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindTickers provides a mock function with given fields: opts
func (_m *MockStorage) FindTickers(opts ...func(*gorm.DB) *gorm.DB) ([]Ticker, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 []Ticker
	var r1 error
	if rf, ok := ret.Get(0).(func(...func(*gorm.DB) *gorm.DB) ([]Ticker, error)); ok {
		return rf(opts...)
	}
	if rf, ok := ret.Get(0).(func(...func(*gorm.DB) *gorm.DB) []Ticker); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]Ticker)
		}
	}

	if rf, ok := ret.Get(1).(func(...func(*gorm.DB) *gorm.DB) error); ok {
		r1 = rf(opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindTickersByIDs provides a mock function with given fields: ids, opts
func (_m *MockStorage) FindTickersByIDs(ids []int, opts ...func(*gorm.DB) *gorm.DB) ([]Ticker, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ids)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 []Ticker
	var r1 error
	if rf, ok := ret.Get(0).(func([]int, ...func(*gorm.DB) *gorm.DB) ([]Ticker, error)); ok {
		return rf(ids, opts...)
	}
	if rf, ok := ret.Get(0).(func([]int, ...func(*gorm.DB) *gorm.DB) []Ticker); ok {
		r0 = rf(ids, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]Ticker)
		}
	}

	if rf, ok := ret.Get(1).(func([]int, ...func(*gorm.DB) *gorm.DB) error); ok {
		r1 = rf(ids, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindUploadByUUID provides a mock function with given fields: uuid
func (_m *MockStorage) FindUploadByUUID(uuid string) (Upload, error) {
	ret := _m.Called(uuid)

	var r0 Upload
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (Upload, error)); ok {
		return rf(uuid)
	}
	if rf, ok := ret.Get(0).(func(string) Upload); ok {
		r0 = rf(uuid)
	} else {
		r0 = ret.Get(0).(Upload)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(uuid)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindUploadsByIDs provides a mock function with given fields: ids
func (_m *MockStorage) FindUploadsByIDs(ids []int) ([]Upload, error) {
	ret := _m.Called(ids)

	var r0 []Upload
	var r1 error
	if rf, ok := ret.Get(0).(func([]int) ([]Upload, error)); ok {
		return rf(ids)
	}
	if rf, ok := ret.Get(0).(func([]int) []Upload); ok {
		r0 = rf(ids)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]Upload)
		}
	}

	if rf, ok := ret.Get(1).(func([]int) error); ok {
		r1 = rf(ids)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindUserByEmail provides a mock function with given fields: email
func (_m *MockStorage) FindUserByEmail(email string) (User, error) {
	ret := _m.Called(email)

	var r0 User
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (User, error)); ok {
		return rf(email)
	}
	if rf, ok := ret.Get(0).(func(string) User); ok {
		r0 = rf(email)
	} else {
		r0 = ret.Get(0).(User)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(email)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindUserByID provides a mock function with given fields: id
func (_m *MockStorage) FindUserByID(id int) (User, error) {
	ret := _m.Called(id)

	var r0 User
	var r1 error
	if rf, ok := ret.Get(0).(func(int) (User, error)); ok {
		return rf(id)
	}
	if rf, ok := ret.Get(0).(func(int) User); ok {
		r0 = rf(id)
	} else {
		r0 = ret.Get(0).(User)
	}

	if rf, ok := ret.Get(1).(func(int) error); ok {
		r1 = rf(id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindUsers provides a mock function with given fields:
func (_m *MockStorage) FindUsers() ([]User, error) {
	ret := _m.Called()

	var r0 []User
	var r1 error
	if rf, ok := ret.Get(0).(func() ([]User, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() []User); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]User)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindUsersByIDs provides a mock function with given fields: ids
func (_m *MockStorage) FindUsersByIDs(ids []int) ([]User, error) {
	ret := _m.Called(ids)

	var r0 []User
	var r1 error
	if rf, ok := ret.Get(0).(func([]int) ([]User, error)); ok {
		return rf(ids)
	}
	if rf, ok := ret.Get(0).(func([]int) []User); ok {
		r0 = rf(ids)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]User)
		}
	}

	if rf, ok := ret.Get(1).(func([]int) error); ok {
		r1 = rf(ids)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindUsersByTicker provides a mock function with given fields: ticker
func (_m *MockStorage) FindUsersByTicker(ticker Ticker) ([]User, error) {
	ret := _m.Called(ticker)

	var r0 []User
	var r1 error
	if rf, ok := ret.Get(0).(func(Ticker) ([]User, error)); ok {
		return rf(ticker)
	}
	if rf, ok := ret.Get(0).(func(Ticker) []User); ok {
		r0 = rf(ticker)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]User)
		}
	}

	if rf, ok := ret.Get(1).(func(Ticker) error); ok {
		r1 = rf(ticker)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetInactiveSettings provides a mock function with given fields:
func (_m *MockStorage) GetInactiveSettings() InactiveSettings {
	ret := _m.Called()

	var r0 InactiveSettings
	if rf, ok := ret.Get(0).(func() InactiveSettings); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(InactiveSettings)
	}

	return r0
}

// GetRefreshIntervalSettings provides a mock function with given fields:
func (_m *MockStorage) GetRefreshIntervalSettings() RefreshIntervalSettings {
	ret := _m.Called()

	var r0 RefreshIntervalSettings
	if rf, ok := ret.Get(0).(func() RefreshIntervalSettings); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(RefreshIntervalSettings)
	}

	return r0
}

// SaveInactiveSettings provides a mock function with given fields: inactiveSettings
func (_m *MockStorage) SaveInactiveSettings(inactiveSettings InactiveSettings) error {
	ret := _m.Called(inactiveSettings)

	var r0 error
	if rf, ok := ret.Get(0).(func(InactiveSettings) error); ok {
		r0 = rf(inactiveSettings)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SaveMessage provides a mock function with given fields: message
func (_m *MockStorage) SaveMessage(message *Message) error {
	ret := _m.Called(message)

	var r0 error
	if rf, ok := ret.Get(0).(func(*Message) error); ok {
		r0 = rf(message)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SaveRefreshIntervalSettings provides a mock function with given fields: refreshInterval
func (_m *MockStorage) SaveRefreshIntervalSettings(refreshInterval RefreshIntervalSettings) error {
	ret := _m.Called(refreshInterval)

	var r0 error
	if rf, ok := ret.Get(0).(func(RefreshIntervalSettings) error); ok {
		r0 = rf(refreshInterval)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SaveTicker provides a mock function with given fields: ticker
func (_m *MockStorage) SaveTicker(ticker *Ticker) error {
	ret := _m.Called(ticker)

	var r0 error
	if rf, ok := ret.Get(0).(func(*Ticker) error); ok {
		r0 = rf(ticker)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SaveUpload provides a mock function with given fields: upload
func (_m *MockStorage) SaveUpload(upload *Upload) error {
	ret := _m.Called(upload)

	var r0 error
	if rf, ok := ret.Get(0).(func(*Upload) error); ok {
		r0 = rf(upload)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SaveUser provides a mock function with given fields: user
func (_m *MockStorage) SaveUser(user *User) error {
	ret := _m.Called(user)

	var r0 error
	if rf, ok := ret.Get(0).(func(*User) error); ok {
		r0 = rf(user)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UploadPath provides a mock function with given fields:
func (_m *MockStorage) UploadPath() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// NewMockStorage creates a new instance of MockStorage. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockStorage(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockStorage {
	mock := &MockStorage{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
