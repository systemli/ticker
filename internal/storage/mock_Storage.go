// Code generated by mockery v2.50.4. DO NOT EDIT.

package storage

import (
	mock "github.com/stretchr/testify/mock"
	pagination "github.com/systemli/ticker/internal/api/pagination"
	gorm "gorm.io/gorm"
)

// MockStorage is an autogenerated mock type for the Storage type
type MockStorage struct {
	mock.Mock
}

// AddTickerUser provides a mock function with given fields: ticker, user
func (_m *MockStorage) AddTickerUser(ticker *Ticker, user *User) error {
	ret := _m.Called(ticker, user)

	if len(ret) == 0 {
		panic("no return value specified for AddTickerUser")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*Ticker, *User) error); ok {
		r0 = rf(ticker, user)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteBluesky provides a mock function with given fields: ticker
func (_m *MockStorage) DeleteBluesky(ticker *Ticker) error {
	ret := _m.Called(ticker)

	if len(ret) == 0 {
		panic("no return value specified for DeleteBluesky")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*Ticker) error); ok {
		r0 = rf(ticker)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteIntegrations provides a mock function with given fields: ticker
func (_m *MockStorage) DeleteIntegrations(ticker *Ticker) error {
	ret := _m.Called(ticker)

	if len(ret) == 0 {
		panic("no return value specified for DeleteIntegrations")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*Ticker) error); ok {
		r0 = rf(ticker)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteMastodon provides a mock function with given fields: ticker
func (_m *MockStorage) DeleteMastodon(ticker *Ticker) error {
	ret := _m.Called(ticker)

	if len(ret) == 0 {
		panic("no return value specified for DeleteMastodon")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*Ticker) error); ok {
		r0 = rf(ticker)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteMessage provides a mock function with given fields: message
func (_m *MockStorage) DeleteMessage(message Message) error {
	ret := _m.Called(message)

	if len(ret) == 0 {
		panic("no return value specified for DeleteMessage")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(Message) error); ok {
		r0 = rf(message)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteMessages provides a mock function with given fields: ticker
func (_m *MockStorage) DeleteMessages(ticker *Ticker) error {
	ret := _m.Called(ticker)

	if len(ret) == 0 {
		panic("no return value specified for DeleteMessages")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*Ticker) error); ok {
		r0 = rf(ticker)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteSignalGroup provides a mock function with given fields: ticker
func (_m *MockStorage) DeleteSignalGroup(ticker *Ticker) error {
	ret := _m.Called(ticker)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSignalGroup")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*Ticker) error); ok {
		r0 = rf(ticker)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteTelegram provides a mock function with given fields: ticker
func (_m *MockStorage) DeleteTelegram(ticker *Ticker) error {
	ret := _m.Called(ticker)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTelegram")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*Ticker) error); ok {
		r0 = rf(ticker)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteTicker provides a mock function with given fields: ticker
func (_m *MockStorage) DeleteTicker(ticker *Ticker) error {
	ret := _m.Called(ticker)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTicker")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*Ticker) error); ok {
		r0 = rf(ticker)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteTickerUser provides a mock function with given fields: ticker, user
func (_m *MockStorage) DeleteTickerUser(ticker *Ticker, user *User) error {
	ret := _m.Called(ticker, user)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTickerUser")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*Ticker, *User) error); ok {
		r0 = rf(ticker, user)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteTickerUsers provides a mock function with given fields: ticker
func (_m *MockStorage) DeleteTickerUsers(ticker *Ticker) error {
	ret := _m.Called(ticker)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTickerUsers")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*Ticker) error); ok {
		r0 = rf(ticker)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteUpload provides a mock function with given fields: upload
func (_m *MockStorage) DeleteUpload(upload Upload) error {
	ret := _m.Called(upload)

	if len(ret) == 0 {
		panic("no return value specified for DeleteUpload")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(Upload) error); ok {
		r0 = rf(upload)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteUploads provides a mock function with given fields: uploads
func (_m *MockStorage) DeleteUploads(uploads []Upload) {
	_m.Called(uploads)
}

// DeleteUploadsByTicker provides a mock function with given fields: ticker
func (_m *MockStorage) DeleteUploadsByTicker(ticker *Ticker) error {
	ret := _m.Called(ticker)

	if len(ret) == 0 {
		panic("no return value specified for DeleteUploadsByTicker")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*Ticker) error); ok {
		r0 = rf(ticker)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteUser provides a mock function with given fields: user
func (_m *MockStorage) DeleteUser(user User) error {
	ret := _m.Called(user)

	if len(ret) == 0 {
		panic("no return value specified for DeleteUser")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(User) error); ok {
		r0 = rf(user)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// FindMessage provides a mock function with given fields: tickerID, messageID, opts
func (_m *MockStorage) FindMessage(tickerID int, messageID int, opts ...func(*gorm.DB) *gorm.DB) (Message, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, tickerID, messageID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FindMessage")
	}

	var r0 Message
	var r1 error
	if rf, ok := ret.Get(0).(func(int, int, ...func(*gorm.DB) *gorm.DB) (Message, error)); ok {
		return rf(tickerID, messageID, opts...)
	}
	if rf, ok := ret.Get(0).(func(int, int, ...func(*gorm.DB) *gorm.DB) Message); ok {
		r0 = rf(tickerID, messageID, opts...)
	} else {
		r0 = ret.Get(0).(Message)
	}

	if rf, ok := ret.Get(1).(func(int, int, ...func(*gorm.DB) *gorm.DB) error); ok {
		r1 = rf(tickerID, messageID, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindMessagesByTicker provides a mock function with given fields: ticker, opts
func (_m *MockStorage) FindMessagesByTicker(ticker Ticker, opts ...func(*gorm.DB) *gorm.DB) ([]Message, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ticker)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FindMessagesByTicker")
	}

	var r0 []Message
	var r1 error
	if rf, ok := ret.Get(0).(func(Ticker, ...func(*gorm.DB) *gorm.DB) ([]Message, error)); ok {
		return rf(ticker, opts...)
	}
	if rf, ok := ret.Get(0).(func(Ticker, ...func(*gorm.DB) *gorm.DB) []Message); ok {
		r0 = rf(ticker, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]Message)
		}
	}

	if rf, ok := ret.Get(1).(func(Ticker, ...func(*gorm.DB) *gorm.DB) error); ok {
		r1 = rf(ticker, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindMessagesByTickerAndPagination provides a mock function with given fields: ticker, _a1, opts
func (_m *MockStorage) FindMessagesByTickerAndPagination(ticker Ticker, _a1 pagination.Pagination, opts ...func(*gorm.DB) *gorm.DB) ([]Message, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ticker, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FindMessagesByTickerAndPagination")
	}

	var r0 []Message
	var r1 error
	if rf, ok := ret.Get(0).(func(Ticker, pagination.Pagination, ...func(*gorm.DB) *gorm.DB) ([]Message, error)); ok {
		return rf(ticker, _a1, opts...)
	}
	if rf, ok := ret.Get(0).(func(Ticker, pagination.Pagination, ...func(*gorm.DB) *gorm.DB) []Message); ok {
		r0 = rf(ticker, _a1, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]Message)
		}
	}

	if rf, ok := ret.Get(1).(func(Ticker, pagination.Pagination, ...func(*gorm.DB) *gorm.DB) error); ok {
		r1 = rf(ticker, _a1, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindTickerByDomain provides a mock function with given fields: domain, opts
func (_m *MockStorage) FindTickerByDomain(domain string, opts ...func(*gorm.DB) *gorm.DB) (Ticker, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, domain)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FindTickerByDomain")
	}

	var r0 Ticker
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...func(*gorm.DB) *gorm.DB) (Ticker, error)); ok {
		return rf(domain, opts...)
	}
	if rf, ok := ret.Get(0).(func(string, ...func(*gorm.DB) *gorm.DB) Ticker); ok {
		r0 = rf(domain, opts...)
	} else {
		r0 = ret.Get(0).(Ticker)
	}

	if rf, ok := ret.Get(1).(func(string, ...func(*gorm.DB) *gorm.DB) error); ok {
		r1 = rf(domain, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindTickerByID provides a mock function with given fields: id, opts
func (_m *MockStorage) FindTickerByID(id int, opts ...func(*gorm.DB) *gorm.DB) (Ticker, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, id)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FindTickerByID")
	}

	var r0 Ticker
	var r1 error
	if rf, ok := ret.Get(0).(func(int, ...func(*gorm.DB) *gorm.DB) (Ticker, error)); ok {
		return rf(id, opts...)
	}
	if rf, ok := ret.Get(0).(func(int, ...func(*gorm.DB) *gorm.DB) Ticker); ok {
		r0 = rf(id, opts...)
	} else {
		r0 = ret.Get(0).(Ticker)
	}

	if rf, ok := ret.Get(1).(func(int, ...func(*gorm.DB) *gorm.DB) error); ok {
		r1 = rf(id, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindTickerByUserAndID provides a mock function with given fields: user, id, opts
func (_m *MockStorage) FindTickerByUserAndID(user User, id int, opts ...func(*gorm.DB) *gorm.DB) (Ticker, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, user, id)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FindTickerByUserAndID")
	}

	var r0 Ticker
	var r1 error
	if rf, ok := ret.Get(0).(func(User, int, ...func(*gorm.DB) *gorm.DB) (Ticker, error)); ok {
		return rf(user, id, opts...)
	}
	if rf, ok := ret.Get(0).(func(User, int, ...func(*gorm.DB) *gorm.DB) Ticker); ok {
		r0 = rf(user, id, opts...)
	} else {
		r0 = ret.Get(0).(Ticker)
	}

	if rf, ok := ret.Get(1).(func(User, int, ...func(*gorm.DB) *gorm.DB) error); ok {
		r1 = rf(user, id, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindTickersByIDs provides a mock function with given fields: ids, opts
func (_m *MockStorage) FindTickersByIDs(ids []int, opts ...func(*gorm.DB) *gorm.DB) ([]Ticker, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ids)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FindTickersByIDs")
	}

	var r0 []Ticker
	var r1 error
	if rf, ok := ret.Get(0).(func([]int, ...func(*gorm.DB) *gorm.DB) ([]Ticker, error)); ok {
		return rf(ids, opts...)
	}
	if rf, ok := ret.Get(0).(func([]int, ...func(*gorm.DB) *gorm.DB) []Ticker); ok {
		r0 = rf(ids, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]Ticker)
		}
	}

	if rf, ok := ret.Get(1).(func([]int, ...func(*gorm.DB) *gorm.DB) error); ok {
		r1 = rf(ids, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindTickersByUser provides a mock function with given fields: user, filter, opts
func (_m *MockStorage) FindTickersByUser(user User, filter TickerFilter, opts ...func(*gorm.DB) *gorm.DB) ([]Ticker, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, user, filter)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FindTickersByUser")
	}

	var r0 []Ticker
	var r1 error
	if rf, ok := ret.Get(0).(func(User, TickerFilter, ...func(*gorm.DB) *gorm.DB) ([]Ticker, error)); ok {
		return rf(user, filter, opts...)
	}
	if rf, ok := ret.Get(0).(func(User, TickerFilter, ...func(*gorm.DB) *gorm.DB) []Ticker); ok {
		r0 = rf(user, filter, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]Ticker)
		}
	}

	if rf, ok := ret.Get(1).(func(User, TickerFilter, ...func(*gorm.DB) *gorm.DB) error); ok {
		r1 = rf(user, filter, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindUploadByUUID provides a mock function with given fields: uuid
func (_m *MockStorage) FindUploadByUUID(uuid string) (Upload, error) {
	ret := _m.Called(uuid)

	if len(ret) == 0 {
		panic("no return value specified for FindUploadByUUID")
	}

	var r0 Upload
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (Upload, error)); ok {
		return rf(uuid)
	}
	if rf, ok := ret.Get(0).(func(string) Upload); ok {
		r0 = rf(uuid)
	} else {
		r0 = ret.Get(0).(Upload)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(uuid)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindUploadsByIDs provides a mock function with given fields: ids
func (_m *MockStorage) FindUploadsByIDs(ids []int) ([]Upload, error) {
	ret := _m.Called(ids)

	if len(ret) == 0 {
		panic("no return value specified for FindUploadsByIDs")
	}

	var r0 []Upload
	var r1 error
	if rf, ok := ret.Get(0).(func([]int) ([]Upload, error)); ok {
		return rf(ids)
	}
	if rf, ok := ret.Get(0).(func([]int) []Upload); ok {
		r0 = rf(ids)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]Upload)
		}
	}

	if rf, ok := ret.Get(1).(func([]int) error); ok {
		r1 = rf(ids)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindUserByEmail provides a mock function with given fields: email, opts
func (_m *MockStorage) FindUserByEmail(email string, opts ...func(*gorm.DB) *gorm.DB) (User, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, email)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FindUserByEmail")
	}

	var r0 User
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...func(*gorm.DB) *gorm.DB) (User, error)); ok {
		return rf(email, opts...)
	}
	if rf, ok := ret.Get(0).(func(string, ...func(*gorm.DB) *gorm.DB) User); ok {
		r0 = rf(email, opts...)
	} else {
		r0 = ret.Get(0).(User)
	}

	if rf, ok := ret.Get(1).(func(string, ...func(*gorm.DB) *gorm.DB) error); ok {
		r1 = rf(email, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindUserByID provides a mock function with given fields: id, opts
func (_m *MockStorage) FindUserByID(id int, opts ...func(*gorm.DB) *gorm.DB) (User, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, id)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FindUserByID")
	}

	var r0 User
	var r1 error
	if rf, ok := ret.Get(0).(func(int, ...func(*gorm.DB) *gorm.DB) (User, error)); ok {
		return rf(id, opts...)
	}
	if rf, ok := ret.Get(0).(func(int, ...func(*gorm.DB) *gorm.DB) User); ok {
		r0 = rf(id, opts...)
	} else {
		r0 = ret.Get(0).(User)
	}

	if rf, ok := ret.Get(1).(func(int, ...func(*gorm.DB) *gorm.DB) error); ok {
		r1 = rf(id, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindUsers provides a mock function with given fields: filter, opts
func (_m *MockStorage) FindUsers(filter UserFilter, opts ...func(*gorm.DB) *gorm.DB) ([]User, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, filter)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FindUsers")
	}

	var r0 []User
	var r1 error
	if rf, ok := ret.Get(0).(func(UserFilter, ...func(*gorm.DB) *gorm.DB) ([]User, error)); ok {
		return rf(filter, opts...)
	}
	if rf, ok := ret.Get(0).(func(UserFilter, ...func(*gorm.DB) *gorm.DB) []User); ok {
		r0 = rf(filter, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]User)
		}
	}

	if rf, ok := ret.Get(1).(func(UserFilter, ...func(*gorm.DB) *gorm.DB) error); ok {
		r1 = rf(filter, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindUsersByIDs provides a mock function with given fields: ids, opts
func (_m *MockStorage) FindUsersByIDs(ids []int, opts ...func(*gorm.DB) *gorm.DB) ([]User, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ids)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FindUsersByIDs")
	}

	var r0 []User
	var r1 error
	if rf, ok := ret.Get(0).(func([]int, ...func(*gorm.DB) *gorm.DB) ([]User, error)); ok {
		return rf(ids, opts...)
	}
	if rf, ok := ret.Get(0).(func([]int, ...func(*gorm.DB) *gorm.DB) []User); ok {
		r0 = rf(ids, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]User)
		}
	}

	if rf, ok := ret.Get(1).(func([]int, ...func(*gorm.DB) *gorm.DB) error); ok {
		r1 = rf(ids, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindUsersByTicker provides a mock function with given fields: ticker, opts
func (_m *MockStorage) FindUsersByTicker(ticker Ticker, opts ...func(*gorm.DB) *gorm.DB) ([]User, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ticker)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FindUsersByTicker")
	}

	var r0 []User
	var r1 error
	if rf, ok := ret.Get(0).(func(Ticker, ...func(*gorm.DB) *gorm.DB) ([]User, error)); ok {
		return rf(ticker, opts...)
	}
	if rf, ok := ret.Get(0).(func(Ticker, ...func(*gorm.DB) *gorm.DB) []User); ok {
		r0 = rf(ticker, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]User)
		}
	}

	if rf, ok := ret.Get(1).(func(Ticker, ...func(*gorm.DB) *gorm.DB) error); ok {
		r1 = rf(ticker, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetInactiveSettings provides a mock function with no fields
func (_m *MockStorage) GetInactiveSettings() InactiveSettings {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetInactiveSettings")
	}

	var r0 InactiveSettings
	if rf, ok := ret.Get(0).(func() InactiveSettings); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(InactiveSettings)
	}

	return r0
}

// GetRefreshIntervalSettings provides a mock function with no fields
func (_m *MockStorage) GetRefreshIntervalSettings() RefreshIntervalSettings {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetRefreshIntervalSettings")
	}

	var r0 RefreshIntervalSettings
	if rf, ok := ret.Get(0).(func() RefreshIntervalSettings); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(RefreshIntervalSettings)
	}

	return r0
}

// ResetTicker provides a mock function with given fields: ticker
func (_m *MockStorage) ResetTicker(ticker *Ticker) error {
	ret := _m.Called(ticker)

	if len(ret) == 0 {
		panic("no return value specified for ResetTicker")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*Ticker) error); ok {
		r0 = rf(ticker)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SaveInactiveSettings provides a mock function with given fields: inactiveSettings
func (_m *MockStorage) SaveInactiveSettings(inactiveSettings InactiveSettings) error {
	ret := _m.Called(inactiveSettings)

	if len(ret) == 0 {
		panic("no return value specified for SaveInactiveSettings")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(InactiveSettings) error); ok {
		r0 = rf(inactiveSettings)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SaveMessage provides a mock function with given fields: message
func (_m *MockStorage) SaveMessage(message *Message) error {
	ret := _m.Called(message)

	if len(ret) == 0 {
		panic("no return value specified for SaveMessage")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*Message) error); ok {
		r0 = rf(message)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SaveRefreshIntervalSettings provides a mock function with given fields: refreshInterval
func (_m *MockStorage) SaveRefreshIntervalSettings(refreshInterval RefreshIntervalSettings) error {
	ret := _m.Called(refreshInterval)

	if len(ret) == 0 {
		panic("no return value specified for SaveRefreshIntervalSettings")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(RefreshIntervalSettings) error); ok {
		r0 = rf(refreshInterval)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SaveTicker provides a mock function with given fields: ticker
func (_m *MockStorage) SaveTicker(ticker *Ticker) error {
	ret := _m.Called(ticker)

	if len(ret) == 0 {
		panic("no return value specified for SaveTicker")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*Ticker) error); ok {
		r0 = rf(ticker)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SaveUpload provides a mock function with given fields: upload
func (_m *MockStorage) SaveUpload(upload *Upload) error {
	ret := _m.Called(upload)

	if len(ret) == 0 {
		panic("no return value specified for SaveUpload")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*Upload) error); ok {
		r0 = rf(upload)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SaveUser provides a mock function with given fields: user
func (_m *MockStorage) SaveUser(user *User) error {
	ret := _m.Called(user)

	if len(ret) == 0 {
		panic("no return value specified for SaveUser")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*User) error); ok {
		r0 = rf(user)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UploadPath provides a mock function with no fields
func (_m *MockStorage) UploadPath() string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for UploadPath")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// NewMockStorage creates a new instance of MockStorage. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockStorage(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockStorage {
	mock := &MockStorage{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
